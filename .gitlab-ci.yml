image: registry.romagnole.com.br/docker_dind-roma

variables:
  IMAGE_TAG: ${REGISTRY_SERVER}/${DOCKER_IMAGE_TAG}

stages:
  - build
  - deploy
  - test

services:
  - registry.romagnole.com.br/docker_dind-roma

.build container: &build
  stage: build
  script:
    - docker build -t ${IMAGE_TAG}:$CI_COMMIT_REF_NAME
      --build-arg APP_PORT="${APP_PORT}"
      --build-arg SYSTEMD_FILE_NAME_SUFFIX="${SYSTEMD_FILE_NAME_SUFFIX}"
      --build-arg SYSTEMD_FILE_NAME_PREFIX="${SYSTEMD_FILE_NAME_PREFIX}"
      --build-arg SYSTEMDFILE_NAME="${SYSTEMDFILE_NAME}"
      --build-arg HTTPD_CONF_PROJ_FILENAME="${HTTPD_CONF_PROJ_FILENAME}"
      --build-arg HTTPD_MAIN_CONF_FILE="${HTTPD_MAIN_CONF_FILE}"
      --build-arg HTTPD_CONF_D_FOLDER="${HTTPD_CONF_D_FOLDER}"
      --build-arg SYSTEMD_FOLDER="${SYSTEMD_FOLDER}"
      --build-arg FWD_DEST_FILENAME="${FWD_DEST_FILENAME}"
      --build-arg CERT_FOLDER="${CERT_FOLDER}"
      --build-arg NODE_VERSION="${NODE_VERSION}"
      --build-arg PROJECT_DIR="${PROJECT_DIR}"
      --build-arg SSL_CERT_KEY="${SSL_CERT_WILDCARD_KEY}"
      --build-arg DOTENV="${DOTENV}"
      --build-arg SSL_CERT="${SSL_CERT_WILDCARD}"
      --build-arg SSL_CERT_KEY_FILENAME="${SSL_CERT_KEY_FILENAME}"
      --build-arg SSL_CERT_FILENAME="${SSL_CERT_FILENAME}"
      --build-arg HTTPD_SITE_CONF_FILE="${HTTPD_SITE_CONF_FILE}"
      --build-arg FWD_FILE="${FWD_FILE}"
      --build-arg SYSTEMD_SERVICE_FILE="${SYSTEMD_SERVICE_FILE}"
      --build-arg SITE_URL="${SITE_URL}"
      --build-arg FWD_ALLOW_INPUT="${FWD_ALLOW_INPUT}"
      --build-arg FIRST_IP="${FIRST_IP}" .
    - docker push ${IMAGE_TAG}:$CI_COMMIT_REF_NAME

build staging:
  <<: *build
  variables:
    FWD_FILENAME: "${FWD_LAN_FILENAME}"
    FWD_FILE: "${FWD_LAN_FILE}"
    FIRST_IP: "${STAGING_FIRST_IP}"
    DOTENV: "${STAGING_ENV}"
    SITE_URL: "${STAGING_SITE_URL}"
    FWD_ALLOW_INPUT: "${STAGING_FWD_ALLOWED_IN}"
  rules:
    - if: $CI_COMMIT_REF_NAME  == "staging"
      when: always

build production:
  <<: *build
  variables:
    FWD_FILENAME: "${FWD_DMZ_FILENAME}"
    FWD_FILE: "${FWD_DMZ_FILE}"
    FIRST_IP: "${PRODUCTION_FIRST_IP}"
    DOTENV: "${PRODUCTION_API_EXTERNA_ENV}"
    SITE_URL: "${PRODUCTION_SITE_URL}"
    FWD_ALLOW_INPUT: "${PRODUCTION_FWD_ALLOWED_IN}"
  rules:
    - if: $CI_COMMIT_REF_NAME  == "master"
      when: always

.deploy template: &deploy
  stage: deploy
  environment:
    name: production
  before_script:
    - mkdir .ssh
    - echo "${SSH_PRIVATE_KEY}" > ${SSH_PRIVATE_KEY_FILE}
    - chmod 600 ${SSH_PRIVATE_KEY_FILE}
    - echo "${ETC_HOSTS}" >> /etc/hosts
    - echo $CI_COMMIT_REF_NAME
  script:
    - ssh -o StrictHostKeyChecking=accept-new -i ${SSH_PRIVATE_KEY_FILE} ${GITLAB_RUNNER_USER}@${SERVER} ls -lt /
    - ssh -i ${SSH_PRIVATE_KEY_FILE} ${GITLAB_RUNNER_USER}@${SERVER} docker pull ${IMAGE_TAG}:$CI_COMMIT_REF_NAME
    - ssh -i ${SSH_PRIVATE_KEY_FILE} ${GITLAB_RUNNER_USER}@${SERVER} mkdir -p ${CONTAINER_HOST_DIR}
    - scp -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY_FILE} ${DOCKER_COMPOSE_FILE} ${GITLAB_RUNNER_USER}@${SERVER}:${CONTAINER_HOST_DIR}/
    - ssh -i ${SSH_PRIVATE_KEY_FILE} ${GITLAB_RUNNER_USER}@${SERVER} cat  ${CONTAINER_HOST_DIR}/${DOCKER_COMPOSE_FILE}
    - echo "IMAGE_TAG=${IMAGE_TAG}:$CI_COMMIT_REF_NAME" > .env
    - echo "CONTAINER_NAME=${DOCKER_CONTAINER_NAME}" >> .env
    - echo "FIRST_IP=${FIRST_IP}" >> .env
    - scp -o StrictHostKeyChecking=no -i ${SSH_PRIVATE_KEY_FILE} .env ${GITLAB_RUNNER_USER}@${SERVER}:${CONTAINER_HOST_DIR}/
    - ssh -i ${SSH_PRIVATE_KEY_FILE} ${GITLAB_RUNNER_USER}@${SERVER} hostname
    - ssh -i ${SSH_PRIVATE_KEY_FILE} ${GITLAB_RUNNER_USER}@${SERVER} pwd
    - ssh -i ${SSH_PRIVATE_KEY_FILE} ${GITLAB_RUNNER_USER}@${SERVER} ls -lt
    - ssh -i ${SSH_PRIVATE_KEY_FILE} ${GITLAB_RUNNER_USER}@${SERVER} docker compose -f ${CONTAINER_HOST_DIR}/${DOCKER_COMPOSE_FILE} --env-file ${CONTAINER_HOST_DIR}/.env  up -d
    - ssh -i ${SSH_PRIVATE_KEY_FILE} ${GITLAB_RUNNER_USER}@${SERVER} sleep 10
    - ssh -i ${SSH_PRIVATE_KEY_FILE} ${GITLAB_RUNNER_USER}@${SERVER} docker exec ${DOCKER_CONTAINER_NAME} systemctl restart httpd || true
    - ssh -i ${SSH_PRIVATE_KEY_FILE} ${GITLAB_RUNNER_USER}@${SERVER} docker exec ${DOCKER_CONTAINER_NAME} systemctl status httpd || true
    - ssh -i ${SSH_PRIVATE_KEY_FILE} ${GITLAB_RUNNER_USER}@${SERVER} docker exec ${DOCKER_CONTAINER_NAME} systemctl status ${SYSTEMD_FILE_NAME_PREFIX}*${SYSTEMD_FILE_NAME_SUFFIX} || true
    - ssh -i ${SSH_PRIVATE_KEY_FILE} ${GITLAB_RUNNER_USER}@${SERVER} docker exec ${DOCKER_CONTAINER_NAME} timedatectl set-timezone ${DEFAULT_TIMEZONE}
    - ssh -i ${SSH_PRIVATE_KEY_FILE} ${GITLAB_RUNNER_USER}@${SERVER} docker exec ${DOCKER_CONTAINER_NAME} timedatectl
#    - ssh -i ${SSH_PRIVATE_KEY_FILE} ${GITLAB_RUNNER_USER}@${SERVER} docker exec ${DOCKER_CONTAINER_NAME} firewall-cmd --list-all

deploy staging:
  <<: *deploy
  variables:
    SERVER: "${STAGING_SERVER}"
    FIRST_IP: "${STAGING_FIRST_IP}"
  environment:
    name: staging
  rules:
    - if: $CI_COMMIT_REF_NAME  == "staging"
      when: always

deploy production:
  <<: *deploy
  variables:
    SERVER: "${PRODUCTION_DMZ_SERVER}"
    FIRST_IP: "${PRODUCTION_FIRST_IP}"
  environment:
    name: staging
  rules:
    - if: $CI_COMMIT_REF_NAME  == "master"
      when: always

.sonarqube-check:
  stage: validate
  image:
    name: sonarsource/sonar-scanner-cli:latest
    entrypoint: [""]
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar" # Defines the location of the analysis task cache
    GIT_DEPTH: "0" # Tells git to fetch all the branches of the project, required by the analysis task
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  before_script:
    - echo "${ETC_HOSTS}" >> /etc/hosts
  script:
    - sonar-scanner
  allow_failure: false # true
  only:
    - develop # or the name of your main branch
